// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using PokeAPI;
//
//    var evoChain = EvoChain.FromJson(jsonString);

namespace PokeAPI.EvoChain
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class EvoChain
    {
        [JsonProperty("baby_trigger_item")]
        public object BabyTriggerItem { get; set; }

        [JsonProperty("chain")]
        public Chain Chain { get; set; }

        [JsonProperty("id")]
        public long Id { get; set; }
    }

    public partial class Chain
    {
        [JsonProperty("evolution_details")]
        public EvolutionDetail[] EvolutionDetails { get; set; }

        [JsonProperty("evolves_to")]
        public Chain[] EvolvesTo { get; set; }

        [JsonProperty("is_baby")]
        public bool IsBaby { get; set; }

        [JsonProperty("species")]
        public terminalProperty Species { get; set; }
    }

    public partial class EvolutionDetail
    {
        [JsonProperty("gender")]
        public object Gender { get; set; }

        [JsonProperty("held_item")]
        public object HeldItem { get; set; }

        [JsonProperty("item")]
        public terminalProperty Item { get; set; }

        [JsonProperty("known_move")]
        public object KnownMove { get; set; }

        [JsonProperty("known_move_type")]
        public terminalProperty KnownMoveType { get; set; }

        [JsonProperty("location")]
        public terminalProperty Location { get; set; }

        [JsonProperty("min_affection")]
        public long? MinAffection { get; set; }

        [JsonProperty("min_beauty")]
        public object MinBeauty { get; set; }

        [JsonProperty("min_happiness")]
        public long? MinHappiness { get; set; }

        [JsonProperty("min_level")]
        public object MinLevel { get; set; }

        [JsonProperty("needs_overworld_rain")]
        public bool NeedsOverworldRain { get; set; }

        [JsonProperty("party_species")]
        public object PartySpecies { get; set; }

        [JsonProperty("party_type")]
        public object PartyType { get; set; }

        [JsonProperty("relative_physical_stats")]
        public object RelativePhysicalStats { get; set; }

        [JsonProperty("time_of_day")]
        public TimeOfDay TimeOfDay { get; set; }

        [JsonProperty("trade_species")]
        public object TradeSpecies { get; set; }

        [JsonProperty("trigger")]
        public terminalProperty Trigger { get; set; }

        [JsonProperty("turn_upside_down")]
        public bool TurnUpsideDown { get; set; }
    }

    public partial class terminalProperty
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }
    }

    public enum TimeOfDay { Day, Empty, Night };

    public partial class EvoChain
    {
        public static EvoChain FromJson(string json) => JsonConvert.DeserializeObject<EvoChain>(json, PokeAPI.EvoChain.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this EvoChain self) => JsonConvert.SerializeObject(self, PokeAPI.EvoChain.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                TimeOfDayConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }


    internal class TimeOfDayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TimeOfDay) || t == typeof(TimeOfDay?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return TimeOfDay.Empty;
                case "day":
                    return TimeOfDay.Day;
                case "night":
                    return TimeOfDay.Night;
            }
            return TimeOfDay.Empty;
            //throw new Exception("Cannot unmarshal type TimeOfDay");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TimeOfDay)untypedValue;
            switch (value)
            {
                case TimeOfDay.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case TimeOfDay.Day:
                    serializer.Serialize(writer, "day");
                    return;
                case TimeOfDay.Night:
                    serializer.Serialize(writer, "night");
                    return;
            }
            throw new Exception("Cannot marshal type TimeOfDay");
        }

        public static readonly TimeOfDayConverter Singleton = new TimeOfDayConverter();
    }
}
